generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* =========================
   Core Auth / Users
   ========================= */

model User {
  id               Int               @id @default(autoincrement())
  username         String            @unique
  email            String            @unique
  password         String
  profilePicture   String?
  phoneNumber      String?           @unique
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  deletedAt        DateTime?         // Soft delete: NULL = active

  // Messaging (DM + Group)
  messagesSent     Message[]         @relation("SentMessages")
  messagesReceived Message[]         @relation("ReceivedMessages")

  // Groups
  groupMemberships GroupMember[]
  createdGroups    Group[]           @relation("UserCreatedGroups")

  // Tokens
  refreshTokens    RefreshToken[]    @relation("UserRefreshTokens")

  // Social graph
  friends          Friend[]          @relation("UserFriends")     // rows where user is the owner
  friendedBy       Friend[]          @relation("UserFriendOf")    // rows where user appears as friend

  // Requests
  requestsSent     ConnectionRequest[] @relation("RequestsSent")
  requestsReceived ConnectionRequest[] @relation("RequestsReceived")
}

/* =========================
   Groups
   ========================= */

model Group {
  id          Int          @id @default(autoincrement())
  name        String
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  createdBy   User         @relation("UserCreatedGroups", fields: [createdById], references: [id])
  createdById Int

  members     GroupMember[]
  messages    Message[]

  @@index([createdById])
}

model GroupMember {
  id       Int      @id @default(autoincrement())
  userId   Int
  groupId  Int
  role     Role
  joinedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Prevent duplicate membership
  @@unique([userId, groupId])
  @@index([groupId, role])
}

enum Role {
  ADMIN
  MEMBER
}

/* =========================
   Messaging
   ========================= */

model Message {
  id          Int          @id @default(autoincrement())
  text        String?
  messageType MessageType  @default(TEXT)
  createdAt   DateTime     @default(now())

  // DM fields (either receiverId set for DM OR groupId set for group)
  senderId    Int
  receiverId  Int?
  groupId     Int?

  sender      User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    User?        @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: SetNull)
  group       Group?       @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Attachments normalized
  attachments MessageAttachment[]

  // Helpful query patterns
  @@index([groupId, createdAt])
  @@index([receiverId, createdAt])
  @@index([senderId, createdAt])
  @@index([createdAt])

  // NOTE: Enforce "only friends can DM" in service logic by checking Friend table
  // before creating a message with receiverId != NULL.
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
}

model MessageAttachment {
  id         Int         @id @default(autoincrement())
  url        String
  type       MessageType
  sizeBytes  Int?
  width      Int?
  height     Int?
  durationMs Int?

  messageId  Int
  message    Message     @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

/* =========================
   Tokens
   ========================= */

model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  createdAt DateTime @default(now())

  user      User     @relation("UserRefreshTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

/* =========================
   Social: Requests & Friends
   ========================= */

model ConnectionRequest {
  id          Int             @id @default(autoincrement())
  requesterId Int
  recipientId Int
  status      RequestStatus   @default(PENDING)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  // Optional soft delete/archive if you want to keep history clean
  resolvedAt  DateTime?

  requester   User            @relation("RequestsSent", fields: [requesterId], references: [id], onDelete: Cascade)
  recipient   User            @relation("RequestsReceived", fields: [recipientId], references: [id], onDelete: Cascade)

  // Prevent duplicate parallel requests between the same pair.
  // If you want multiple over time, reuse this row and update status.
  @@unique([requesterId, recipientId])

  @@index([status, createdAt])
  @@index([recipientId, status, createdAt])
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELED
}

/**
 * Friend rows are stored per-direction to make "list my friends" simple and fast.
 * On ACCEPT of a ConnectionRequest, create TWO rows:
 *   (userId = A, friendId = B) and (userId = B, friendId = A)
 * This also makes it easy to cascade on user delete.
 */
model Friend {
  id        Int      @id @default(autoincrement())
  userId    Int
  friendId  Int
  createdAt DateTime @default(now())

  user      User     @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend    User     @relation("UserFriendOf", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId]) // no duplicates per direction
  @@index([friendId])
}
